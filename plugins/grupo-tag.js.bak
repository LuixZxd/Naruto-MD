import { generateWAMessageFromContent } from '@whiskeysockets/baileys'

let handler = async (m, { conn, args, command }) => {  
  global.listadoGrupos = global.listadoGrupos || []  
  
  if (['listgroup', 'grouplist'].includes(command)) {  
    let txt = ''  
    global.listadoGrupos = []  

    const groups = Object.entries(conn.chats).filter(([jid, chat]) => jid.endsWith('@g.us') && chat.isChats)  
    const totalGroups = groups.length  

    for (let i = 0; i < totalGroups; i++) {  
      const [jid] = groups[i]  
      const metadata = ((conn.chats[jid] || {}).metadata || (await conn.groupMetadata(jid).catch(() => null))) || {}  
      const participants = metadata.participants || []  
      const bot = participants.find(u => conn.decodeJid(u.id) === conn.user.jid) || {}  
      const isBotAdmin = bot?.admin || false  
      const isParticipant = participants.some(u => conn.decodeJid(u.id) === conn.user.jid)  
      const participantStatus = isParticipant ? 'Participante' : 'Ex-participante'  
      const totalParticipants = participants.length  
      const groupName = metadata.subject || await conn.getName(jid)  
      const groupLink = isBotAdmin  
        ? `https://chat.whatsapp.com/${await conn.groupInviteCode(jid).catch(() => '') || 'Error'}`  
        : '(No disponible: sin permisos de admin)'  

      global.listadoGrupos.push({ jid, nombre: groupName })  

      txt += `â•”â•â•â•â•â•â• âŠ¹Grupo #${i + 1}âŠ¹ â•â•â•â•â•â•â•—  
â•   Nombre: ${groupName}  
â•   ID: ${jid}  
â•   Admin: ${isBotAdmin ? 'SÃ­' : 'No'}  
â•   Estado: ${participantStatus}  
â•   Participantes: ${totalParticipants}  
â•   Link: ${groupLink}  
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`  
    }  

    m.reply(`ğŸ“‹ *Lista de grupos del bot*\n\nTotal: ${totalGroups} grupos encontrados.\n\n${txt}`.trim())  

  } else if (command == 'salirg') {  
    const num = parseInt(args[0])  
    if (!num || !global.listadoGrupos[num - 1]) return m.reply('âŒ Grupo no encontrado. Usa primero *.listgroup*')  

    const { jid, nombre } = global.listadoGrupos[numero - 1]  

    await conn.sendMessage(jid, {  
      text: `ğŸ‘‹ *${conn.user.name}* se despide de este grupo.\nGracias por todo. Â¡Hasta pronto! âœ¨`  
    })  

    await conn.groupLeave(jid)  
    await m.reply(`ğŸšª SalÃ­ del grupo *${nombre}* correctamente.`)  

  } else if (command == 'aviso') {  
    // Sintaxis: .aviso <nÃºmero> | <mensaje>  
    const texto = args.join(' ').split('|')  
    const numero = parseInt(texto[0])  
    const mensaje = texto[1]?.trim()  
    if (!numero) return m.reply(`âš ï¸ Uso: *.aviso <nÃºmero> | <mensaje>*\nEjemplo: *.aviso 2 | Hola grupo!*`)  
    if (!global.listadoGrupos[numero - 1]) return m.reply('âŒ Grupo no encontrado. Usa primero *.listgroup*')  

    const { jid, nombre } = global.listadoGrupos[numero - 1]  

    let q = m.quoted ? m.quoted : m
    let textoAviso = mensaje ? `ğŸ“¢ *AVISO DEL CREADOR*\n\n${mensaje}` : "ğŸ“¢ *AVISO DEL CREADOR*"

    // Obtener todos los participantes para hidetag
    const metadata = await conn.groupMetadata(jid)
    const users = metadata.participants.map(u => conn.decodeJid(u.id))

    // Revisar si es media
    let mime = (q.msg || q).mimetype || ''
    let isMedia = /image|video|sticker|audio/.test(mime)

    if (isMedia) {
        let media = await q.download?.()
        if (q.mtype === 'imageMessage') await conn.sendMessage(jid, { image: media, caption: textoAviso, mentions: users })
        else if (q.mtype === 'videoMessage') await conn.sendMessage(jid, { video: media, caption: textoAviso, mentions: users, mimetype: 'video/mp4' })
        else if (q.mtype === 'audioMessage') await conn.sendMessage(jid, { audio: media, mimetype: 'audio/mp4', fileName: `Aviso.mp3`, mentions: users })
        else if (q.mtype === 'stickerMessage') await conn.sendMessage(jid, { sticker: media, mentions: users }) // <-- sticker enviado correctamente
    } else {
        await conn.sendMessage(jid, { text: textoAviso, mentions: users })
    }

    m.reply(`âœ… Aviso enviado a *${nombre}*`)
  }  
}  

handler.help = ['listgroup', 'salirg <nÃºmero>', 'aviso <nÃºmero> | <mensaje> (o responder con archivo)']  
handler.tags = ['owner']  
handler.command = ['listgroup', 'salirg', 'aviso', 'grouplist']  
handler.rowner = true  

export default handler